import fs from 'fs'
import path from 'path'
import chokidar from 'chokidar'
import chalk from 'chalk'
import debounce from 'lodash/debounce'

import {Task} from '../../build/index'
import {compareStructures, i18n, Reporter, utils} from '../../../../../lib/hope/lib/index'

const TAB = 2;

export default function ({fromDir = 'model', toDir = 'data'} = {}) {

  const toDirRel = path.relative(__dirname, path.join(process.cwd(), fromDir, toDir));

  return new Task({
    name: `Compile from '${fromDir}/' to '${toDir}/model'`,
    async run() {
      try {

        deleteRequireCache(require.resolve('../../../../../lib/hope/lib'));

        const {loader: DSCLoader, config: DSCConfig} = require('../../../../../lib/hope/lib/index');

        const MAX_MESSAGES = 30;

        class ReporterImpl extends Reporter {
          _print(type, msg) {

            if (this.messages > MAX_MESSAGES) {
              if (this.messages === (MAX_MESSAGES + 1)) console.warn('...');
              return;
            }

            switch (type) {
              case 'error': {
                console.error(chalk.red(msg));
                break;
              }
              case 'warn': {
                console.warn(chalk.yellow(msg));
                break;
              }
              case 'info': {
                console.info(chalk.green(msg));
                break;
              }
            }
          }
        }

        const nonLocalResult = new ReporterImpl();
        const messages = DSCConfig.messages(nonLocalResult);
        if (nonLocalResult.isError) return;

        const result = new ReporterImpl(messages);

        const model = await DSCLoader(result, path.join(process.cwd(), fromDir));

        const hasValidators = model.hasOwnProperty('validators');

        const config = result.isError || DSCConfig.compile(result, {
          ...model,
          docs: model.docs.items,
          api: model.api && model.api.items
        });

        if (result.isError) throw new Error(`Compilation failed`);

        const unlinkedConfig = DSCConfig.unlink(config);

        fs.writeFileSync(path.join(process.cwd(), `${toDir}/model.json`), JSON.stringify(unlinkedConfig, null, 2));

        const code = {
          docs: model.docs.code,
          api: model.api && model.api.code,
          validators: hasValidators
        };

        fs.writeFileSync(path.join(process.cwd(), `${toDir}/model.code.js`), loadScript(code, path.join(process.cwd(), toDir)));

        fs.writeFileSync(path.join(process.cwd(), `${toDir}/model.server.code.js`), loadScript(code, path.join(process.cwd(), toDir), true));

        deleteRequireCache(require.resolve(path.join(process.cwd(), `${toDir}/model.code.js`)));

        // const linkedConfig = DSCConfig.link(utils.deepClone(unlinkedConfig), require('../data/model.code.js').default);
        const linkedConfig = DSCConfig.link(utils.deepClone(unlinkedConfig), true);

        // TODO: Собрать с helper'проверить $$validate и $$access на $$new

        // compareStructures(result, linkedConfig, config, 'error');

        !result.isError && compareStructures(result, DSCConfig.unlink(linkedConfig), unlinkedConfig, 'error');

        if (result.isError) throw new Error(`Link/unlink mismatch`);

        // TODO: Build client version of model

      } catch (err) {
        console.error(err);
        throw err;
      }
    },
    watch(cb) {
      chokidar.watch(path.resolve(process.cwd(), '../lib/hope/lib/**/*'), {ignoreInitial: true}).on('all', debounce(cb, 1000));
      chokidar.watch(path.join(process.cwd(), fromDir, '/**/*'), {ignoreInitial: true}).on('all', cb);
    },
  });

  function deleteRequireCache(id) {
    if (!id || ~id.indexOf('node_modules')) return;
    const m = require.cache[id];
    if (m !== undefined) {
      Object.keys(m.children).forEach(function (file) {
        deleteRequireCache(m.children[file].id);
      });
      delete require.cache[id];
    }
  }

  function loadScript(code, scriptPath, server) {
    let tab = 0;
    const res = [];

    res.push(`// NOTE: Do not edit this file manually.  It's generated by the build task\n`);

    if (server) {
      res.push(`${' '.repeat(tab)}import oncePerServices from '${path.relative(scriptPath, path.join(process.cwd(), `src/common/services/oncePerServices`)).replace(/\\/g, '/')}'\n`);
      res.push(`${' '.repeat(tab)}export default oncePerServices(function (services) {`);
      tab += TAB;
      res.push(`${' '.repeat(tab)}return {`);
      tab += TAB;
    } else {
      res.push(`${' '.repeat(tab)}export default {`);
      tab += TAB;
    }

    if (code.docs) {

      res.push(`${' '.repeat(tab)}docs: {`);
      tab += TAB;

      Object.entries(code.docs).forEach(([docName, docCode]) => {

        res.push(`${' '.repeat(tab)}'${docName.indexOf('.') !== -1 ? docName : `doc.${docName}`}': {`);
        tab += TAB;

        if (server && docCode.actions) {
          res.push(`${' '.repeat(tab + TAB)}actions: require('${path.relative(scriptPath, docCode.actions).replace(/\\/g, '/')}').default(services),`);
        }

        Object.entries(docCode).forEach(([methodName, methodPath]) => {

          if (methodName === 'actions') return;

          res.push(`${' '.repeat(tab + TAB)}${methodName}: require('${path.relative(scriptPath, methodPath).replace(/\\/g, '/')}').default,`);
        });

        tab -= TAB;
        res.push(`${' '.repeat(tab)}},`);
      });

      tab -= TAB;
      res.push(`${' '.repeat(tab)}},`);
    }

    if (code.api) {

      res.push(`${' '.repeat(tab)}api: {`);
      tab += TAB;

      Object.entries(code.api).forEach(([apiName, apiCode]) => {

        res.push(`${' '.repeat(tab)}${apiName}: {`);
        tab += TAB;

        Object.entries(apiCode).forEach(([methodName, methodCode]) => {

          res.push(`${' '.repeat(tab)}${methodName}: {`);
          tab += TAB;

          Object.entries(methodCode).forEach(([methodName, methodPath]) => {
            res.push(`${' '.repeat(tab + TAB)}${methodName}: require('${path.relative(scriptPath, methodPath).replace(/\\/g, '/')}').default,`);
          });

          tab -= TAB;
          res.push(`${' '.repeat(tab)}},`);
        });

        tab -= TAB;
        res.push(`${' '.repeat(tab)}},`);

      });

      tab -= TAB;
      res.push(`${' '.repeat(tab)}},`);
    }

    if (code.validators) res.push(`${' '.repeat(tab)}validators: require('${path.relative(scriptPath, `${fromDir}/validators`).replace(/\\/g, '/')}'),`);

    tab -= TAB;
    res.push(`${' '.repeat(tab)}};`);

    if (server) {
      tab -= TAB;
      res.push(`${' '.repeat(tab)}});`);
    }

    return res.join('\n');
  };
};
